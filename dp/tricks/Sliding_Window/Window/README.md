#### 一些说明

滑动窗口策略一般处理序列问题，约定一个窗口（窗口大小可以固定也可以不定），使得该窗口从序列第一个元素依次往后滑动，并且在每轮滑动过程中，
计算或者查找当前窗口范围内满足某种要求的序列元素。往往题目中包含
```
请找到满足xx的最x的区间（子串、子数组）的xx
```
这样类似的语句时，我们都可以考虑采用滑动窗口策略解决。

##### 1，固定窗口大小 (单调队列优化)
首先，如果我们不考虑计算复杂度的情况下，可以直接用下面的代码来简单模拟固定窗口大小的滑动过程
```python
# arr: 给定数组
# k: 固定窗口大小

ans = []  # 存放题目要求的某些数组中元素
for i in range(n-k+1):
  tmp = arr[i:i+k]   # 当前窗口
  # 比如找出每个窗口中的最小值
  ans.append(min(tmp))
```
上面的`for`循环就是模型窗口滑动的过程，但是实际处理的时候，这样直接调用内置函数处理，很可能会超时。

所以我们考虑采用其他能降低计算复杂度的策略，总的想法还是模拟窗口滑动的过程。

针对固定窗口大小为`k`的问题，我们介绍一下单调队列优化的策略。不妨还是以"找出每个窗口中最小值"要求为例。
* 首先，若使用一般的队列`deque`进行模拟，那么对每一个窗口deque，为了找出满足要求的元素，那么时间复杂度为`O(k)`，
然后窗口往后移动的时间复杂度为`O(n)`，这里`n`表示数组长度。那么总的时间复杂度为`O(n*k)`。当`n`很大，并且`k`比较接近，那么时间复杂度接近`O(n^2)`。
* 根据上面的分析，我们考虑对队列加上一些要求，使得总的复杂度降为`O(n)`。对于找最小值的问题，
我们要求队列中元素(或者对应到原数组中的数)呈现递增的的规律，换句话说，在每次移动的过程中，我们维护一个单调递增的队列。
具体地，在每次往队列(窗口)尾部添加当前遍历元素之前cur，先判断当前遍历元素cur和队尾元素对应的数组元素arr[deque[tail]]大小，
```
while ...:
  1，若cur <= arr[deque[tail]]，说明将cur的下标添加入deque后，对应arr中的数不能形成递增的趋势。所以这时，我们不断地将deque尾部
     元素弹出，直到将cur下标入队后对应的各数能形成递增趋势时，就将cur对应的下标入队。
  2，若cur > arr[deque[tail]]，说明将cur入队后，对应元素满足递增趋势，那么直接将其下标入队，并同时更新tail位置。
```
因此，在不断入队出队的过程中，每一轮位于队首下标对应的元素就是当前窗口的最小值。具体的代码如下，
```python
def minSlidingWindow(self, nums: List[int], k: int) -> List[int]:
    """找出每个窗口中的最小值"""
    if (nums == []) or (k < 0):
        return 0
    q = []  # 用来表示单调队列，维护的是数组nums中对应元素的下标
    head, tail = 0, -1   # 设置为队列的头尾位置
    ans = []   # 存放当前窗口的最大值
    for i in range(len(nums)):
        # 若队列头位置对应的数组nums下标位置不超过i-k(窗口大小为k)，说明头位置还可以往后移动
        if (head <= tail) and (q[head] <= i-k):
            head += 1
        # 每轮找出当前窗口最大值，所以队尾对应的nums中元素在队列中呈现单调下降趋势
        # 也就是说，如果当前遍历元素nums[i]大于队尾对应的nums中元素，那么一直将队尾下标往左移
        while (head <= tail) and (nums[q[tail]] >= nums[i]):
            tail -= 1
            q.pop()
        # 直到将当前元素nums[i]对应的下标加入队列后，能使得队列中各下标对应的nums元素呈现下降趋势
        q.append(i)
        tail += 1
        # 由于窗口大小为k，所以当遍历下标元素i大于k-1时，
        # 维护的单调下降队列，在每次更新完之后，队首位置对应的下标元素nums[q[head]]就是当前窗口最大值
        if (i >= k-1):
            ans.append(nums[q[head]])
    return ans
```
若要找的是每个窗口中的最大值，类似地，我们将代码中`while`循环部分大小的判断修改即可，其余完全相同。

当前，对于`while`循环部分大小判断的代码，我们还可以换做`lambda`语句，进一步简化，比如，
```python
def max_min(arr, func):
    q = deque()
    ans = []
    for i, v in enumerate(arr):
        if q and (q[0][0] <= i-k):
            q.popleft()   # 相当于上面代码中 head += 1
        while q and func(v, q[-1][1]):
            q.pop()   # 相当于上面代码 tail -= 1
        q.append((i, v))
        if (i >= k-1):
            ans.append(q[0][1])
    return ans

ans_min = Solution_1().max_min(arr, lambda x, y: x <= y)   # 单调递增队列 -> 找最小值
ans_max = Solution_1().max_min(arr, lambda x, y: x >= y)   # 单调递减队列 -> 找最大值
```

应用：
* AcWing-154/leetcode-239 滑动窗口最值查找
* AcWing-6 多重背包问题_III



##### 2，非固定窗口大小
这种情况下，我们还是手动模拟窗口滑动过程，算法的逻辑如下
```python
# 设置双指针，都从首位置开始遍历
left, right = 0, 0
while right < len(arr):    # arr表示给定的数组，字符串等
  # 增大窗口，也就是窗口右边界right右移
  window.append(arr[right])
  right += 1
  # 判断当前窗口是否应该收缩
  while (left < right) and (其他判断条件):
    # 缩小
    window.remove(arr[left])
    left += 1
    
  (进行元素处理，比如统计，计算，对比等操作...)
```
这个算法逻辑的时间复杂度是`O(n)`，`n`是数组`arr`的长度，比一般的暴力遍历效率要高。

但是，在上面的算法框架中，还有一些细节问题没有处理，比如
* 怎么向窗口中添加新元素？
* 怎么缩小窗口？
* 在窗口滑动的哪个阶段更新结果？
* 出现`bug`后，怎么查找比较有效？
* ......

下面，我们对上面的框架补充点细节处理代码，以字符串输入为例
```python
def slidingWindow(s: string, t: string):
  need = {}    # 需要在字符串中处理的各字符的个数
  window = {}  # 记录当前的遍历的窗口
  # 在need中统计字符串t中各字符个数
  # 同时将window中在t中出现的各字符串个数初始化为0，便于接下来遍历记录
  for num in t:
    need[c] += 1
    window[c] = 0
  # 设置双指针
  left, right = 0, 0 
  # 设置为在当前窗口中已经处理的need中对应字符的个数
  valid = 0
  
  # 开始进行窗口滑动
  while right < len(s):
    # 将是s[right]移入当前窗口
    c = s[right]
    right += 1   # 窗口右边界右移
    # 对窗口内数据进行更新
    ......
    
    # debug 输出位置
    print('window: [%d, %d)', left, right)
    
    # 判断当前窗口是否需要收缩
    while (left <right) and (其他判断条件):
      # 将s[left]移除当前窗口
      d = s[left]
      left += 1
      # 对窗口内数据进行更新
      ......
```
上面框架中`......`分别表示对窗口左右移动过程进行相应处理更新，在实际中几乎是对称的操作。

应用：
* leetcode-239. 滑动窗口最大值
* leetcode-209. 长度最小的子数组
* leetcode-713. 乘积小于K的子数组
* leetcode-76. 最小覆盖子串
* leetcode-567. 字符串的排列 / leetcode-438. 找到字符串中所有字母异位词
* 百度笔试题-字符串匹配
* leetcode-3. 无重复字符的最长子串
