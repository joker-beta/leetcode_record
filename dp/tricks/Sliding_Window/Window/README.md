#### 一些说明

滑动窗口策略一般处理序列问题，约定一个窗口（窗口大小可以固定也可以不定），使得该窗口从序列第一个元素依次往后滑动，并且在每轮滑动过程中，
计算或者查找当前窗口范围内满足某种要求的序列元素。往往题目中包含
```
请找到满足xx的最x的区间（子串、子数组）的xx
```
这样类似的语句时，我们都可以考虑采用滑动窗口策略解决。

##### 1，固定窗口大小 (单调队列优化)
首先，如果我们不考虑计算复杂度的情况下，可以直接用下面的代码来简单模拟固定窗口大小的滑动过程
```python
# arr: 给定数组
# k: 固定窗口大小

ans = []  # 存放题目要求的某些数组中元素
for i in range(n-k+1):
  tmp = arr[i:i+k]   # 当前窗口
  # 比如找出每个窗口中的最小值
  ans.append(min(tmp))
```
上面的`for`循环就是模型窗口滑动的过程，但是实际处理的时候，这样直接调用内置函数处理，很可能会超时。

所以我们考虑采用其他能降低计算复杂度的策略，总的想法还是模拟窗口滑动的过程。

针对固定窗口大小为`k`的问题，我们介绍一下单调队列优化的策略。不妨还是以"找出每个窗口中最小值"要求为例。
* 首先，若使用一般的队列`deque`进行模拟，那么对每一个窗口deque，为了找出满足要求的元素，那么时间复杂度为`O(k)`，
然后窗口往后移动的时间复杂度为`O(n)`，这里`n`表示数组长度。那么总的时间复杂度为`O(n*k)`。当`n`很大，并且`k`比较接近，那么时间复杂度接近`O(n^2)`。
* 根据上面的分析，我们考虑对队列加上一些要求，使得总的复杂度降为`O(n)`。对于找最小值的问题，
我们要求队列中元素(或者对应到原数组中的数)呈现递增的的规律，换句话说，在每次移动的过程中，我们维护一个单调递增的队列。
具体地，在每次往队列(窗口)尾部添加当前遍历元素之前cur，先判断当前遍历元素cur和队尾元素对应的数组元素arr[deque[tail]]大小，
```
while ...:
  1，若cur <= arr[deque[tail]]，说明将cur的下标添加入deque后，对应arr中的数不能形成递增的趋势。所以这时，我们不断地将deque尾部
     元素弹出，直到将cur下标入队后对应的各数能形成递增趋势时，就将cur对应的下标入队。
  2，若cur > arr[deque[tail]]，说明将cur入队后，对应元素满足递增趋势，那么直接将其下标入队，并同时更新tail位置。
```
因此，在不断入队出队的过程中，每一轮位于队首下标对应的元素就是当前窗口的最小值。具体的代码如下，
```python
def minSlidingWindow(self, nums: List[int], k: int) -> List[int]:
    """找出每个窗口中的最小值"""
    if (nums == []) or (k < 0):
        return 0
    q = []  # 用来表示单调队列，维护的是数组nums中对应元素的下标
    head, tail = 0, -1   # 设置为队列的头尾位置
    ans = []   # 存放当前窗口的最大值
    for i in range(len(nums)):
        # 若队列头位置对应的数组nums下标位置不超过i-k(窗口大小为k)，说明头位置还可以往后移动
        if (head <= tail) and (q[head] <= i-k):
            head += 1
        # 每轮找出当前窗口最大值，所以队尾对应的nums中元素在队列中呈现单调下降趋势
        # 也就是说，如果当前遍历元素nums[i]大于队尾对应的nums中元素，那么一直将队尾下标往左移
        while (head <= tail) and (nums[q[tail]] >= nums[i]):
            tail -= 1
            q.pop()
        # 直到将当前元素nums[i]对应的下标加入队列后，能使得队列中各下标对应的nums元素呈现下降趋势
        q.append(i)
        tail += 1
        # 由于窗口大小为k，所以当遍历下标元素i大于k-1时，
        # 维护的单调下降队列，在每次更新完之后，队首位置对应的下标元素nums[q[head]]就是当前窗口最大值
        if (i >= k-1):
            ans.append(nums[q[head]])
    return ans
```
若要找的是每个窗口中的最大值，类似地，我们将代码中`while`循环部分大小的判断修改即可，其余完全相同。

当前，对于`while`循环部分大小判断的代码，我们还可以换做`lambda`语句，进一步简化，比如，
```python
def max_min(arr, func):
    q = deque()
    ans = []
    for i, v in enumerate(arr):
        if q and (q[0][0] <= i-k):
            q.popleft()   # 相当于上面代码中 head += 1
        while q and func(v, q[-1][1]):
            q.pop()   # 相当于上面代码 tail -= 1
        q.append((i, v))
        if (i >= k-1):
            ans.append(q[0][1])
    return ans

ans_min = Solution_1().max_min(arr, lambda x, y: x <= y)   # 单调递增队列 -> 找最小值
ans_max = Solution_1().max_min(arr, lambda x, y: x >= y)   # 单调递减队列 -> 找最大值
```


