### 一些说明
[问题]：有`N`件物品和一个容量为`V`的背包。放入第`i`件物品消耗费的费用是`C_i`，得到的价值是`W_i`。计算将哪些物品装入背包可以使得总价值最大。   


#### 1，01背包
[特点]：每种物品只有一件，可以选择放或者不放。

处理背包问题的基本思路主要包含三步，
* 第一步：明确`[状态]`和`[选择]`，
  * 先是状态，如何描述一个问题的局面？只要给定几个可以选择的物品和一个背包的容量限制，就形成了一个背包问题，所以状态有
  两个，就是`[背包的容量]`和`[可以选择的物品]`
  * 然后是选择，对于每一件物品，我们可以选择`[装入背包]`或者`[不装入背包]`。
```python
for 状态1 in 状态1的所有的取值:
    for 状态2 in 状态2的所有取值:
        for ...
            dp[状态1][状态2][...] = 择优(选择1, 选择2,...)
```

* 第二步：明确`dp`数组的定义。
```python
dp[i][w] 表示对前i个物品，当前背包的容量为w时，可以装下的最大价值.
```
根据这个定义，我们要求的最终答案就是`dp[n][w]`，另外边界条件的处理，那么这个过程的代码描述为
```python
# 表示没有物品或者背包没有空间的时候，能装入的最大价值就是0.
dp[0][*] = dp[*][0] = 0

for i in range(1, n+1):
    for j in range(1, w+1):
        dp[i][j] = max(把coins[i]装进背包, 不把coins[i]装进背包)   # 状态转移
return dp[n][w]      
```

* 第三步：明确状态转移方程
简单来说就是，怎么把上面的状态转移用代码描述，这时我们可以分情况讨论如下
  * 若没有把第`i`个物品装进背包，那么
```python
dp[i][j] = dp[i-1][j]
```
  说明当前遍历时不装，那么继承之前的结果。
  * 若将第`i`个物品装进背包，那么
```python
dp[i][j] = dp[i - 1][j - w[i-1]] + v[i-1]
```
  说明在剩下的前`i-1`个物品中考虑选择物品装进容量为`j - w[i-1]`的背包，同时由于第`i`个物品装进的背包，那么需要将其价值考虑进来`v[i-1]`。
  
所以，我们将上面描述的过程用代码实现如下
```python
def fun(w, n, wt, val):
    # dp[i][j] 表示前i个物品，当背包重量为j时，所能装下的最大价值
    dp = [[0 for j in range(n + 1)] for i in range(w + 1)]
    for i in range(1, n + 1):
	for j in range(1, w + 1):
	    # 当前背包容量装不下，只能选择不装入背包
	    if (j - w[i-1]) < 0:
	       dp[i][j] = dp[i - 1][j]
	    # 若当前背包容量j能装下第i个物品的重量w[i-1]，
            # 那么考虑装入或者不装入背包两种状况，然后选择价值最大的情况
	    else:
	       dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i - 1])				
   return dp[n][w]
```
  
#### 2，完全背包
[特点]：每件物品有无限件。也就是从每种物品的角度考虑，与它相关的策略不是取或者不取两种，而是有取`0`件，取`1`件，取`2`件，...直到取`[V/C_i]`件等许多种。

我们首先沿用`01`背包的思路，写出状态转移方程
```python
dp[i][j] = max({dp[i - 1][j - k*C_i] + k*W_i: 0<= k*C_i <= j})
```
这和`01`背包一样有`O(VN)`个状态需要求解，但求解每个状态的时间已经不是常数，求解`dp[i][j]`的时间是`O(j/C_i)`，总的复杂度认为是`O(N*V* sum_i(j/C_i))`，数比较大。对于上面的状态转移方程，我们做些简化，注意到
```python
dp[i][j - C_i] = max({dp[i - 1][j - C_i - k*C_i] + k*W_i: 0 <= k*C_i <= j-C_i})
# 将上式带入dp[i][j]得到
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - C_i] + W_i, ..., dp[i - 1][j - [j/C_i]*C_i] + [j/C_i]*W_i)
         = max(dp[i - 1][j], dp[i][j - C_i] + W_i)
```
所以根据上面的推导知道`dp[i][j]`只与上一层`dp[i-1][j]`和这一层`dp[i][j-C_i]`相关，所以进一步可以将上面的状态方程简化为一维的数组
```python
dp[j] = max(dp[j], dp[j - C_i] + W_i)
```
这样，我们将运算复杂度减小到`O(V*N)`。


#### 3，多重背包
[特点]：第`i`种物品总共有`M_i`件，而不是完全背包的可以取无限件。

但是，对于状态转移方程可以写出类似的形式
```python
dp[i][j] = max(dp[i-1][j], dp[i - 1][j - C_i] + W_i, ..., dp[i - 1][j - M_i*C_i] + M_i*W_i)	 
```
对于上面方程的处理，根据问题数据范围(量)的大小，我们可以有下面的三种办法。

##### 3.1 数据量较少
这时，对于转移方程，最简单的可以直接用三个循环挨个的比较最大，找到最终的答案，比如`AcWing-4`问题中的数据量大小。主要的循环代码如下，
```python
for i in range(N):
  for j in range(V):
    for k in range(M_i):  # 这里的M_i，W_i，C_i是形式上的写法，具体的值根据问题来确定
      dp[i][j] = max(dp[i][j], dp[i-1][j - k*C_i] + k*W_i)
```
由上面的代码分析，可以知道时间复杂度为`O(N*V*sum_{i}M_i)`。

##### 3.2 数据量稍大
这时，若仍然采用上面的无脑循环，很可能超时，比如`AcWing-5`问题中的数据量。那么为了进一步减小计算复杂度，这里我们可以考虑利用二进制分组的办法将时间复杂度降低到 `O(N*V*sum_{i}log(M_i))`。

如果我们要取1000个苹果，那么只需要对现有的苹果分为10个箱子，
每个箱子里的苹果数就是二进制的对应的数(2^0, 2^1, 2^2, 2^3, 2^4, ..., 2^9)，由于2^10 = 1024
所以我们此时最多取10次箱子就可以了，按照这个想法，当需要拿取的苹果数越多时，相比之前的方法，二进制的办法能够降低运算复杂度。

因此，我们将类似的想法应用到这个问题上，那么对于上面的状态转移方程
在每一轮状态 
```python
dp[i - 1][j - k*vi] + k*wi, (0 <= k <= si)
```
进行对比取最大的过程之前，我们可以先对si进行二进制分组，假设`mi = max({t: 2^t <= si, t>=0})`，那么对`si`进行分组 
```python
(2^0, 2^1, 2^2, ..., 2^mi, si-2^0-2^1-...-2^mi)
```
那么取当前第`i`种物品，背包中增加的重量为下面二进制分组后列表中的一个
```python
[2^0 * goods[i][0], 2^1 * goods[i][0], 2^2 * goods[i][0], ..., 2^mi * goods[i][0], (si-2^0-2^1-...-2^mi) * goods[i][0]]
```
同样地，那么取当前第`i`种物品，获得的价值也是下面二进制分组后列表中的一个
```python
[2^0 * goods[i][1], 2^1 * goods[i][1], 2^2 * goods[i][1], ..., 2^mi * goods[i][1], (si-2^0-2^1-...-2^mi) * goods[i][1]]
```
其中`i = 0, 1, ..., N-1`。

也就是说，我们将原问题中每种物品最多选取固定个数，来计算最大价值的问题，通过二进制分组转化为从上面两个列表中选择或者不选择能获得最大价值的`01`背包问题。代码如下，
```python
def fun(N, V, goods):
	v = []  # 存储分组后各物品的重量
	w = []  # 存储分组后各物品的价值
	cnt = 0  # 分组的组别
	for i in range(N):
 	   k = 1  # 用于每一轮对各物品的重量和价值进行二进制分组更新存放
 	   s = goods[i][2]  # 当前重量为goods[i][0]的物品，价值为goods[i][1]，并且有goods[i][2]个

 	   # 下面whlie循环和if判断中的代码是对s进行二进制分组处理
  	   while k <= s:
		v.append(k * goods[i][0])
		w.append(k * goods[i][1])
		s -= k  # s 每轮减小
		k *= 2  # 组别里面的个数增加
		cnt += 1  # 每一轮划分完组别后，更新组别数
	
	    # 若s余下的数不能表示成2的幂次，那么就单独作为一个组别
	    # 比如，若s=10，那么分组为(2^0*X, 2^1*X, 2^2*X, (s - 2^0 - 2^1 - 2^2)*X) = (1*X, 2*X, 4*X, 3*X)
	    # 其中X表示各物品的重量(goods[i][0])或者价值(goods[i][1])
	    if s > 0:
		v.append(s * goods[i][0])
		w.append(s * goods[i][1])
		cnt += 1  # 更新组别数

	n = cnt  # 枚举次数由输入的个数转化为组别数

	# 接下来转化为01背包问题处理，这里直接写成优化后的一维数组形式
	dp = [0 for _ in range(V + 1)]
	for i in range(n):
	    for j in range(V, v[i] - 1, -1):
		dp[j] = max(dp[j], dp[j - v[i]] + w[i])
	return dp[-1]
```

##### 3.3 数据量更大
当数据量更大的时候比如`AcWing-6`问题，采用上面二进制分组的策略可能还是会超时，那么我们考虑进一步将计算时间复杂度降低为 `O(N*V)`。

这里，我们根据一般多重背包问题的分析知道状态方程为
```python
F[i, j] = max{F[i - 1, j - k*vi] + k*wi: 0 <= k <= si, 0 < j - k*ci}
```
* 在`AcWing-4`中，由于数据范围较小我们直接通过循环嵌套进行处理。
* 在`AcWing-5`中，数据范围变大一些，我们通过对`si`进行二进制分组的策略，将总的时间复杂度降低了。
在当前的问题中，数据范围变得更大，我们考虑将问题转化为单调队列优化问题(或者说滑动窗口策略)。

注意到上面的方程可以化简为一维形式
```python
f[j] = max{f[j - k*ci] + k*wi: 0 <= k <= si, 0 < j - k*ci}
```
发现`f[j]`仅仅依赖`f[j - k*ci]`，按照依赖性对`f[j]`进行`模ci`分组。
```math
[数学推导]：
              f[j + p*ci] = max{f[j + k*ci] + (p-k)*wi: 0 <= k <= p}
 ==>   f[j + p*ci] - p*wi = max{f[j + k*ci] - k*wi: 0 <= k <= p}
```
那么我们将 `f[j + p*ci] - p*wi` 转换成了标准的滑动窗口单调队列形式，即
```python
f[x] - (x - j)/ci * wi，
```
对于 `x = j + p*ci` 构成单调队列。主要代码如下，
```python
def fun(N, V, goods):
    # 设置单调队列
    q = deque()
    dp = [0 for _ in range(V + 1)]
    # 对N种物品进行迭代
    for i in range(N):
        [vi, wi, si] = goods[i]
        # 对当前物品goods[i]的各重量迭代
        for j in range(vi):
            # 每次新的循环都需要初始化队列
            # 由于这里用单调队列对每种物品的重量进行滑动窗口操作
            q.clear()
            nums = (V - j) // vi  # 剩余的空间最多还能放几个当前物品
            for k in range(nums + 1):
                val = dp[j + k*vi] - k*wi
                # 1，若当前队列非空，并且队尾元素记录的元素小于等于当前元素val
                #    那么为了使得队列存放的数呈现递减趋势，需要将队尾元素删除
                while q and q[-1][1] <= val:
                    q.pop()
                # 2，否则，继续往队列中添加元素
                q.append([k, val])

                # 存放的个数不能超出物品数量，否则将元素弹出
                if q[0][0] < k - si:
                    q.popleft()
                dp[j + k*vi] = q[0][1] + k*wi
    return dp[V]
```





#### 4，混合三种背包


#### 5，二维费用的背包


#### 6，分组背包



#### 7，有依赖的背包


#### 8，泛化物品


#### 9，背包问题的变化
