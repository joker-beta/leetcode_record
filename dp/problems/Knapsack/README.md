### 一些说明
[问题]：有`N`件物品和一个容量为`V`的背包。放入第`i`件物品消耗费的费用是`C_i`，得到的价值是`W_i`。计算将哪些物品装入背包可以使得总价值最大。   


#### 1，01背包
[特点]：每种物品只有一件，可以选择放或者不放。

处理背包问题的基本思路主要包含三步，
* 第一步：明确`[状态]`和`[选择]`，
  * 先是状态，如何描述一个问题的局面？只要给定几个可以选择的物品和一个背包的容量限制，就形成了一个背包问题，所以状态有
  两个，就是`[背包的容量]`和`[可以选择的物品]`
  * 然后是选择，对于每一件物品，我们可以选择`[装入背包]`或者`[不装入背包]`。
```python
for 状态1 in 状态1的所有的取值:
    for 状态2 in 状态2的所有取值:
        for ...
            dp[状态1][状态2][...] = 择优(选择1, 选择2,...)
```

* 第二步：明确`dp`数组的定义。
```python
dp[i][w] 表示对前i个物品，当前背包的容量为w时，可以装下的最大价值.
```
根据这个定义，我们要求的最终答案就是`dp[n][w]`，另外边界条件的处理，那么这个过程的代码描述为
```python
# 表示没有物品或者背包没有空间的时候，能装入的最大价值就是0.
dp[0][*] = dp[*][0] = 0

for i in range(1, n+1):
    for j in range(1, w+1):
        dp[i][j] = max(把coins[i]装进背包, 不把coins[i]装进背包)   # 状态转移
return dp[n][w]      
```

* 第三步：明确状态转移方程
简单来说就是，怎么把上面的状态转移用代码描述，这时我们可以分情况讨论如下
  * 若没有把第`i`个物品装进背包，那么
```python
dp[i][j] = dp[i-1][j]
```
  说明当前遍历时不装，那么继承之前的结果。
  * 若将第`i`个物品装进背包，那么
```python
dp[i][j] = dp[i-1][j-w[i-1]] + v[i-1]
```
  说明在剩下的前`i-1`个物品中考虑选择物品装进容量为`j-w[i-1]`的背包，同时由于第`i`个物品装进的背包，那么需要将其价值考虑进来`v[i-1]`。
  
所以，我们将上面描述的过程用代码实现如下
```python
def fun(w, n, wt, val):
    # dp[i][j] 表示前i个物品，当背包重量为j时，所能装下的最大价值
    dp = [[0 for j in range(n + 1)] for i in range(w + 1)]
    for i in range(1, n + 1):
	for j in range(1, w + 1):
	    # 当前背包容量装不下，只能选择不装入背包
	    if (j - w[i-1]) < 0:
	       dp[i][j] = dp[i - 1][j]
	    # 若当前背包容量j能装下第i个物品的重量w[i-1]，
            # 那么考虑装入或者不装入背包两种状况，然后选择价值最大的情况
	    else:
	       dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i - 1])				
   return dp[n][w]
```
  
#### 2，完全背包
[特点]：每件物品有无限件。也就是从每种物品的角度考虑，与它相关的策略不是取或者不取两种，而是有取`0`件，取`1`件，取`2`件，...直到取`[V/C_i]`件等许多种。

我们首先沿用`01`背包的思路，写出状态转移方程
```python
dp[i][j] = max({dp[i - 1][j - k*C_i] + k*W_i: 0<= k*C_i <= j})
```
这和`01`背包一样有`O(VN)`个状态需要求解，但求解每个状态的时间已经不是常数，求解`dp[i][j]`的时间是`O(j/C_i)`，总的复杂度认为是`O(N*V* sum_i(j/C_i))`，数比较大。对于上面的状态转移方程，我们做些简化，注意到
```python
dp[i][j-C_i] = max({dp[i - 1][j - C_i - k*C_i] + k*W_i: 0 <= k*C_i <= j-C_i})
# 将上式带入dp[i][j]得到
dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - C_i] + W_i, ..., dp[i - 1][j - [j/C_i]*C_i] + [j/C_i]*W_i)
         = max(dp[i - 1][j], dp[i][j - C_i] + W_i)
```
所以根据上面的推导知道`dp[i][j]`只与上一层`dp[i-1][j]`和这一层`dp[i][j-C_i]`相关，所以进一步可以将上面的状态方程简化为一维的数组
```python
dp[j] = max(dp[j], dp[j - C_i] + W_i)
```
这样，我们将运算复杂度减小到`O(V*N)`。


#### 3，多重背包
[特点]：第`i`种物品总共有`M_i`件，而不是完全背包的可以取无限件。

但是，对于状态转移方程可以写出类似的形式
```python
# dp[i][j] = max(dp[i-1][j], dp[i - 1][j - C_i] + W_i, ..., dp[i - 1][j - M_i*C_i] + M_i*W_i)	  
           = max(dp[i-1][j], a[i-1][M_i-1], dp[i - 1][j - M_i*C_i] + M_i*W_i)
for i in range(N):
  for j in range(V):
    for k in range(M_i):  # 这里的M_i，W_i，C_i是形式上的写法，具体的值根据问题来确定
      dp[i][j] = max(dp[i][j], dp[i-1][j - k*C_i] + k*W_i)
```
由上面的代码分析，可以知道时间复杂度为`O(N*V*sum_{i}M_i)`，所以我们考虑将问题进行简化，一般考虑从dp[i][j]相邻的项来进行分析，试着找出递推关系。



#### 4，混合三种背包


#### 5，二维费用的背包


#### 6，分组背包



#### 7，有依赖的背包


#### 8，泛化物品


#### 9，背包问题的变化
