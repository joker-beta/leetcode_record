### 一些说明
[问题]：有`N`件物品和一个容量为`V`的背包。放入第`i`件物品消耗费的费用是`C_i`，得到的价值是`W_i`。计算将哪些物品装入背包可以使得总价值最大。   


#### 1，01背包
[特点]：每种物品只有一件，可以选择放或者不放。

处理背包问题的基本思路主要包含三步，
* 第一步：明确`[状态]`和`[选择]`，
  * 先是状态，如何描述一个问题的局面？只要给定几个可以选择的物品和一个背包的容量限制，就形成了一个背包问题，所以状态有
  两个，就是`[背包的容量]`和`[可以选择的物品]`
  * 然后是选择，对于每一件物品，我们可以选择`[装入背包]`或者`[不装入背包]`。
```python
for 状态1 in 状态1的所有的取值:
    for 状态2 in 状态2的所有取值:
        for ...
            dp[状态1][状态2][...] = 择优(选择1, 选择2,...)
```

* 第二步：明确`dp`数组的定义。
```python
dp[i][w] 表示对前i个物品，当前背包的容量为w时，可以装下的最大价值.
```
根据这个定义，我们要求的最终答案就是`dp[n][w]`，另外边界条件的处理，那么这个过程的代码描述为
```python
# 表示没有物品或者背包没有空间的时候，能装入的最大价值就是0.
dp[0][*] = dp[*][0] = 0

for i in range(1, n+1):
    for j in range(1, w+1):
        dp[i][j] = max(把coins[i]装进背包, 不把coins[i]装进背包)   # 状态转移
return dp[n][w]      
```

* 第三步：明确状态转移方程
简单来说就是，怎么把上面的状态转移用代码描述，这时我们可以分情况讨论如下
  * 若没有把第`i`个物品装进背包，那么
```python
dp[i][j] = dp[i-1][j]
```
  说明当前遍历时不装，那么继承之前的结果。
  * 若将第`i`个物品装进背包，那么
```python
dp[i][j] = dp[i-1][j-w[i-1]] + v[i-1]
```
  说明在剩下的前`i-1`个物品中考虑选择物品装进容量为`j-w[i-1]`的背包，同时由于第`i`个物品装进的背包，那么需要将其价值考虑进来`v[i-1]`。
  
所以，我们将上面描述的过程用代码实现如下
```python
def fun(w, n, wt, val):
	   # dp[i][j] 表示前i个物品，当背包重量为j时，所能装下的最大价值
	   dp = [[0 for j in range(n + 1)] for i in range(w + 1)]
    
	   for i in range(1, n + 1):
		      for j in range(1, w + 1):
			     # 当前背包容量装不下，只能选择不装入背包
			     if (j - w[i-1]) < 0:
  				     dp[i][j] = dp[i - 1][j]
		   	  # 若当前背包容量j能装下第i个物品的重量w[i-1]，
        # 那么考虑装入或者不装入背包两种状况，然后选择价值最大的情况
			     else:
				       dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i - 1]] + v[i - 1])				
	  return dp[n][w] 
```
  
#### 2，完全背包


#### 3，多重背包


#### 4，混合三种背包


#### 5，二维费用的背包


#### 6，分组背包



#### 7，有依赖的背包


#### 8，泛化物品


#### 9，背包问题的变化
